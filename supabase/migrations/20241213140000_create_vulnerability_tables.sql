-- =====================================================
-- Migration: Create Vulnerability and Secrets Tables
-- Created: 2024-12-13T14:00:00Z
-- Tables: security_scans, vulnerabilities, secrets, secret_rotations
-- Purpose: Implement vulnerability scanning and secrets management
-- =====================================================

-- Enable UUID extension (idempotent)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Enable pgcrypto for encryption functions
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Helper function for updated_at (idempotent)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- TABLE: security_scans
-- Purpose: Track security scans and their results
-- =====================================================
CREATE TABLE IF NOT EXISTS security_scans (
  id VARCHAR(100) PRIMARY KEY,
  scan_type VARCHAR(50) NOT NULL CHECK (scan_type IN ('dependency', 'code', 'container', 'infrastructure', 'secrets')),
  target TEXT NOT NULL,
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'running', 'completed', 'failed')),
  started_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  completed_at TIMESTAMPTZ,
  total_vulnerabilities INTEGER DEFAULT 0,
  critical_vulnerabilities INTEGER DEFAULT 0,
  high_vulnerabilities INTEGER DEFAULT 0,
  medium_vulnerabilities INTEGER DEFAULT 0,
  low_vulnerabilities INTEGER DEFAULT 0,
  summary TEXT,
  recommendations TEXT[],
  error_message TEXT,
  options JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Performance indexes
CREATE INDEX IF NOT EXISTS security_scans_scan_type_idx ON security_scans(scan_type);
CREATE INDEX IF NOT EXISTS security_scans_status_idx ON security_scans(status);
CREATE INDEX IF NOT EXISTS security_scans_started_at_idx ON security_scans(started_at DESC);

-- Auto-update trigger
DROP TRIGGER IF EXISTS update_security_scans_updated_at ON security_scans;
CREATE TRIGGER update_security_scans_updated_at
  BEFORE UPDATE ON security_scans
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE security_scans ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Only admins can access security scans
CREATE POLICY "security_scans_admin_only"
  ON security_scans FOR ALL
  USING (EXISTS (
    SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin'
  ));

-- =====================================================
-- TABLE: vulnerabilities
-- Purpose: Store discovered vulnerabilities
-- =====================================================
CREATE TABLE IF NOT EXISTS vulnerabilities (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  scan_id VARCHAR(100) REFERENCES security_scans(id) ON DELETE CASCADE NOT NULL,
  severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
  category VARCHAR(50) NOT NULL CHECK (category IN ('dependency', 'code', 'configuration', 'infrastructure', 'secrets')),
  title VARCHAR(200) NOT NULL,
  description TEXT NOT NULL,
  cve VARCHAR(20),
  cvss_score DECIMAL(3,1),
  affected_component VARCHAR(200) NOT NULL,
  file_path TEXT,
  line_number INTEGER,
  remediation TEXT NOT NULL,
  references TEXT[] DEFAULT '{}',
  status VARCHAR(20) DEFAULT 'open' CHECK (status IN ('open', 'in_progress', 'resolved', 'false_positive', 'accepted_risk')),
  assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  due_date TIMESTAMPTZ,
  resolved_at TIMESTAMPTZ,
  resolution_notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Performance indexes
CREATE INDEX IF NOT EXISTS vulnerabilities_scan_id_idx ON vulnerabilities(scan_id);
CREATE INDEX IF NOT EXISTS vulnerabilities_severity_idx ON vulnerabilities(severity);
CREATE INDEX IF NOT EXISTS vulnerabilities_category_idx ON vulnerabilities(category);
CREATE INDEX IF NOT EXISTS vulnerabilities_status_idx ON vulnerabilities(status);
CREATE INDEX IF NOT EXISTS vulnerabilities_assigned_to_idx ON vulnerabilities(assigned_to);
CREATE INDEX IF NOT EXISTS vulnerabilities_created_at_idx ON vulnerabilities(created_at DESC);

-- Auto-update trigger
DROP TRIGGER IF EXISTS update_vulnerabilities_updated_at ON vulnerabilities;
CREATE TRIGGER update_vulnerabilities_updated_at
  BEFORE UPDATE ON vulnerabilities
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE vulnerabilities ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Only admins can access vulnerabilities
CREATE POLICY "vulnerabilities_admin_only"
  ON vulnerabilities FOR ALL
  USING (EXISTS (
    SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin'
  ));

-- =====================================================
-- TABLE: secrets
-- Purpose: Store encrypted secrets and credentials
-- =====================================================
CREATE TABLE IF NOT EXISTS secrets (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  type VARCHAR(50) NOT NULL CHECK (type IN ('api_key', 'password', 'token', 'certificate', 'private_key', 'database_url')),
  description TEXT,
  environment VARCHAR(20) NOT NULL CHECK (environment IN ('development', 'staging', 'production')),
  encrypted_value TEXT NOT NULL,
  encryption_key TEXT NOT NULL,
  is_encrypted BOOLEAN DEFAULT TRUE,
  last_rotated TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT TRUE,
  tags TEXT[] DEFAULT '{}',
  created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Performance indexes
CREATE INDEX IF NOT EXISTS secrets_name_idx ON secrets(name);
CREATE INDEX IF NOT EXISTS secrets_type_idx ON secrets(type);
CREATE INDEX IF NOT EXISTS secrets_environment_idx ON secrets(environment);
CREATE INDEX IF NOT EXISTS secrets_is_active_idx ON secrets(is_active);
CREATE INDEX IF NOT EXISTS secrets_created_at_idx ON secrets(created_at DESC);

-- Auto-update trigger
DROP TRIGGER IF EXISTS update_secrets_updated_at ON secrets;
CREATE TRIGGER update_secrets_updated_at
  BEFORE UPDATE ON secrets
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE secrets ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Only admins can access secrets
CREATE POLICY "secrets_admin_only"
  ON secrets FOR ALL
  USING (EXISTS (
    SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin'
  ));

-- =====================================================
-- TABLE: secret_rotations
-- Purpose: Track secret rotation history
-- =====================================================
CREATE TABLE IF NOT EXISTS secret_rotations (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  secret_id UUID REFERENCES secrets(id) ON DELETE CASCADE NOT NULL,
  rotated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  rotated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Performance indexes
CREATE INDEX IF NOT EXISTS secret_rotations_secret_id_idx ON secret_rotations(secret_id);
CREATE INDEX IF NOT EXISTS secret_rotations_rotated_at_idx ON secret_rotations(rotated_at DESC);

-- Enable Row Level Security
ALTER TABLE secret_rotations ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Only admins can access secret rotations
CREATE POLICY "secret_rotations_admin_only"
  ON secret_rotations FOR ALL
  USING (EXISTS (
    SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin'
  ));

-- =====================================================
-- TABLE: vulnerability_assignments
-- Purpose: Track vulnerability assignments and progress
-- =====================================================
CREATE TABLE IF NOT EXISTS vulnerability_assignments (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  vulnerability_id UUID REFERENCES vulnerabilities(id) ON DELETE CASCADE NOT NULL,
  assigned_to UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  assigned_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  assigned_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  due_date TIMESTAMPTZ,
  status VARCHAR(20) DEFAULT 'assigned' CHECK (status IN ('assigned', 'in_progress', 'completed', 'rejected')),
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  UNIQUE(vulnerability_id, assigned_to)
);

-- Performance indexes
CREATE INDEX IF NOT EXISTS vulnerability_assignments_vulnerability_id_idx ON vulnerability_assignments(vulnerability_id);
CREATE INDEX IF NOT EXISTS vulnerability_assignments_assigned_to_idx ON vulnerability_assignments(assigned_to);
CREATE INDEX IF NOT EXISTS vulnerability_assignments_status_idx ON vulnerability_assignments(status);
CREATE INDEX IF NOT EXISTS vulnerability_assignments_due_date_idx ON vulnerability_assignments(due_date);

-- Auto-update trigger
DROP TRIGGER IF EXISTS update_vulnerability_assignments_updated_at ON vulnerability_assignments;
CREATE TRIGGER update_vulnerability_assignments_updated_at
  BEFORE UPDATE ON vulnerability_assignments
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE vulnerability_assignments ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Users can see their own assignments, admins can see all
CREATE POLICY "vulnerability_assignments_select_own"
  ON vulnerability_assignments FOR SELECT
  USING (auth.uid() = assigned_to OR EXISTS (
    SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin'
  ));

CREATE POLICY "vulnerability_assignments_admin_manage"
  ON vulnerability_assignments FOR INSERT, UPDATE, DELETE
  USING (EXISTS (
    SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin'
  ));

-- =====================================================
-- FUNCTIONS: Vulnerability management utilities
-- =====================================================

-- Function to get vulnerability statistics
CREATE OR REPLACE FUNCTION get_vulnerability_stats()
RETURNS TABLE (
  total_vulnerabilities BIGINT,
  critical_vulnerabilities BIGINT,
  high_vulnerabilities BIGINT,
  medium_vulnerabilities BIGINT,
  low_vulnerabilities BIGINT,
  open_vulnerabilities BIGINT,
  resolved_vulnerabilities BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*) as total_vulnerabilities,
    COUNT(*) FILTER (WHERE severity = 'critical') as critical_vulnerabilities,
    COUNT(*) FILTER (WHERE severity = 'high') as high_vulnerabilities,
    COUNT(*) FILTER (WHERE severity = 'medium') as medium_vulnerabilities,
    COUNT(*) FILTER (WHERE severity = 'low') as low_vulnerabilities,
    COUNT(*) FILTER (WHERE status = 'open') as open_vulnerabilities,
    COUNT(*) FILTER (WHERE status = 'resolved') as resolved_vulnerabilities
  FROM vulnerabilities;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get security scan summary
CREATE OR REPLACE FUNCTION get_scan_summary(p_scan_id VARCHAR(100))
RETURNS TABLE (
  scan_id VARCHAR(100),
  scan_type VARCHAR(50),
  status VARCHAR(20),
  total_vulnerabilities INTEGER,
  critical_vulnerabilities INTEGER,
  high_vulnerabilities INTEGER,
  medium_vulnerabilities INTEGER,
  low_vulnerabilities INTEGER,
  security_score INTEGER
) AS $$
DECLARE
  scan_record RECORD;
  vuln_stats RECORD;
BEGIN
  -- Get scan details
  SELECT * INTO scan_record
  FROM security_scans
  WHERE id = p_scan_id;
  
  IF NOT FOUND THEN
    RETURN;
  END IF;
  
  -- Get vulnerability statistics
  SELECT 
    COUNT(*) as total,
    COUNT(*) FILTER (WHERE severity = 'critical') as critical,
    COUNT(*) FILTER (WHERE severity = 'high') as high,
    COUNT(*) FILTER (WHERE severity = 'medium') as medium,
    COUNT(*) FILTER (WHERE severity = 'low') as low
  INTO vuln_stats
  FROM vulnerabilities
  WHERE scan_id = p_scan_id;
  
  -- Calculate security score (0-100)
  DECLARE
    security_score INTEGER := 100;
  BEGIN
    security_score := security_score - (vuln_stats.critical * 20);
    security_score := security_score - (vuln_stats.high * 10);
    security_score := security_score - (vuln_stats.medium * 5);
    security_score := security_score - (vuln_stats.low * 2);
    security_score := GREATEST(0, security_score);
  END;
  
  RETURN QUERY
  SELECT 
    scan_record.id,
    scan_record.scan_type,
    scan_record.status,
    COALESCE(vuln_stats.total, 0)::INTEGER,
    COALESCE(vuln_stats.critical, 0)::INTEGER,
    COALESCE(vuln_stats.high, 0)::INTEGER,
    COALESCE(vuln_stats.medium, 0)::INTEGER,
    COALESCE(vuln_stats.low, 0)::INTEGER,
    security_score;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to assign vulnerability
CREATE OR REPLACE FUNCTION assign_vulnerability(
  p_vulnerability_id UUID,
  p_assigned_to UUID,
  p_assigned_by UUID,
  p_due_date TIMESTAMPTZ DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
  assignment_id UUID;
BEGIN
  INSERT INTO vulnerability_assignments (
    vulnerability_id,
    assigned_to,
    assigned_by,
    due_date
  ) VALUES (
    p_vulnerability_id,
    p_assigned_to,
    p_assigned_by,
    p_due_date
  ) RETURNING id INTO assignment_id;
  
  -- Update vulnerability status
  UPDATE vulnerabilities
  SET 
    assigned_to = p_assigned_to,
    due_date = p_due_date,
    status = 'in_progress'
  WHERE id = p_vulnerability_id;
  
  RETURN assignment_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to rotate secret
CREATE OR REPLACE FUNCTION rotate_secret(
  p_secret_id UUID,
  p_new_encrypted_value TEXT,
  p_new_encryption_key TEXT,
  p_rotated_by UUID,
  p_reason TEXT DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
  -- Update secret
  UPDATE secrets
  SET 
    encrypted_value = p_new_encrypted_value,
    encryption_key = p_new_encryption_key,
    last_rotated = NOW()
  WHERE id = p_secret_id;
  
  -- Record rotation
  INSERT INTO secret_rotations (
    secret_id,
    rotated_by,
    reason
  ) VALUES (
    p_secret_id,
    p_rotated_by,
    p_reason
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =====================================================
-- TRIGGERS: Automatic updates
-- =====================================================

-- Function to update vulnerability status when assignment changes
CREATE OR REPLACE FUNCTION update_vulnerability_status_on_assignment()
RETURNS TRIGGER AS $$
BEGIN
  -- Update vulnerability status based on assignment status
  IF NEW.status = 'completed' THEN
    UPDATE vulnerabilities
    SET 
      status = 'resolved',
      resolved_at = NOW()
    WHERE id = NEW.vulnerability_id;
  ELSIF NEW.status = 'rejected' THEN
    UPDATE vulnerabilities
    SET 
      status = 'open',
      assigned_to = NULL,
      due_date = NULL
    WHERE id = NEW.vulnerability_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for assignment status changes
DROP TRIGGER IF EXISTS update_vulnerability_status_on_assignment_trigger ON vulnerability_assignments;
CREATE TRIGGER update_vulnerability_status_on_assignment_trigger
  AFTER UPDATE ON vulnerability_assignments
  FOR EACH ROW
  EXECUTE FUNCTION update_vulnerability_status_on_assignment();

-- =====================================================
-- ROLLBACK INSTRUCTIONS (for documentation only)
-- =====================================================
-- To rollback this migration, execute:
-- DROP TABLE IF EXISTS vulnerability_assignments CASCADE;
-- DROP TABLE IF EXISTS secret_rotations CASCADE;
-- DROP TABLE IF EXISTS secrets CASCADE;
-- DROP TABLE IF EXISTS vulnerabilities CASCADE;
-- DROP TABLE IF EXISTS security_scans CASCADE;
-- DROP FUNCTION IF EXISTS get_vulnerability_stats CASCADE;
-- DROP FUNCTION IF EXISTS get_scan_summary CASCADE;
-- DROP FUNCTION IF EXISTS assign_vulnerability CASCADE;
-- DROP FUNCTION IF EXISTS rotate_secret CASCADE;
-- DROP FUNCTION IF EXISTS update_vulnerability_status_on_assignment CASCADE;