/**
 * Vulnerability Scanning and Secrets Management Service
 * Handles security scanning, vulnerability detection, and secrets management
 */

import { supabase } from '@/lib/supabase';
import { encryptData, generateKey } from '@/lib/security';
// import type { Database } from '@/lib/supabase';

// Database types - these tables don't exist yet
// type Vulnerability = any;
// type SecurityScan = any;
// type Secret = any;

export interface VulnerabilityReport {
  id: string;
  scanId: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: 'dependency' | 'code' | 'configuration' | 'infrastructure';
  title: string;
  description: string;
  cve?: string;
  cvssScore?: number;
  affectedComponent: string;
  filePath?: string;
  lineNumber?: number;
  remediation: string;
  references: string[];
  discoveredAt: string;
  status: 'open' | 'in_progress' | 'resolved' | 'false_positive' | 'accepted_risk';
  assignedTo?: string;
  dueDate?: string;
  resolvedAt?: string;
}

export interface SecurityScanResult {
  id: string;
  scanType: 'dependency' | 'code' | 'container' | 'infrastructure' | 'secrets';
  status: 'pending' | 'running' | 'completed' | 'failed';
  startedAt: string;
  completedAt?: string;
  totalVulnerabilities: number;
  criticalVulnerabilities: number;
  highVulnerabilities: number;
  mediumVulnerabilities: number;
  lowVulnerabilities: number;
  vulnerabilities: VulnerabilityReport[];
  summary: string;
  recommendations: string[];
}

export interface SecretInfo {
  id: string;
  name: string;
  type: 'api_key' | 'password' | 'token' | 'certificate' | 'private_key' | 'database_url';
  description: string;
  environment: 'development' | 'staging' | 'production';
  isEncrypted: boolean;
  lastRotated?: string;
  expiresAt?: string;
  isActive: boolean;
  tags: string[];
  createdAt: string;
  updatedAt: string;
}

export interface VulnerabilityMetrics {
  totalVulnerabilities: number;
  criticalVulnerabilities: number;
  highVulnerabilities: number;
  mediumVulnerabilities: number;
  lowVulnerabilities: number;
  openVulnerabilities: number;
  resolvedVulnerabilities: number;
  averageResolutionTime: number;
  topVulnerabilityTypes: Array<{ type: string; count: number }>;
  securityScore: number;
}

export class VulnerabilityService {
  private static instance: VulnerabilityService;
  private scanQueue: string[] = [];
  private isScanning = false;

  private constructor() {
    this.startScanProcessor();
  }

  public static getInstance(): VulnerabilityService {
    if (!VulnerabilityService.instance) {
      VulnerabilityService.instance = new VulnerabilityService();
    }
    return VulnerabilityService.instance;
  }

  /**
   * Start vulnerability scan
   */
  public async startScan(
    scanType: SecurityScanResult['scanType'],
    target: string,
    options: Record<string, any> = {}
  ): Promise<string> {
    try {
      const scanId = `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Create scan record
      const { error: scanError } = await supabase
        .from('security_scans')
        .insert({
          id: scanId,
          scan_type: scanType,
          target,
          status: 'pending',
          started_at: new Date().toISOString(),
          options
        })
        .select()
        .single();

      if (scanError) {
        console.error('Failed to create scan record:', scanError);
        throw scanError;
      }

      // Add to scan queue
      this.scanQueue.push(scanId);
      this.processScanQueue();

      return scanId;
    } catch (error) {
      console.error('Start scan failed:', error);
      throw error;
    }
  }

  /**
   * Process scan queue
   */
  private async processScanQueue(): Promise<void> {
    if (this.isScanning || this.scanQueue.length === 0) return;

    this.isScanning = true;

    while (this.scanQueue.length > 0) {
      const scanId = this.scanQueue.shift();
      if (scanId) {
        await this.executeScan(scanId);
      }
    }

    this.isScanning = false;
  }

  /**
   * Execute vulnerability scan
   */
  private async executeScan(scanId: string): Promise<void> {
    try {
      // Update scan status to running
      await supabase
        .from('security_scans')
        .update({ status: 'running' })
        .eq('id', scanId);

      // Get scan details
      const { data: scan, error: scanError } = await supabase
        .from('security_scans')
        .select('*')
        .eq('id', scanId)
        .single();

      if (scanError) {
        throw scanError;
      }

      // Execute scan based on type
      let vulnerabilities: VulnerabilityReport[] = [];
      
      switch (scan.scan_type) {
        case 'dependency':
          vulnerabilities = await this.scanDependencies(scan.target);
          break;
        case 'code':
          vulnerabilities = await this.scanCode(scan.target);
          break;
        case 'container':
          vulnerabilities = await this.scanContainer(scan.target);
          break;
        case 'infrastructure':
          vulnerabilities = await this.scanInfrastructure(scan.target);
          break;
        case 'secrets':
          vulnerabilities = await this.scanSecrets(scan.target);
          break;
        default:
          throw new Error(`Unknown scan type: ${scan.scan_type}`);
      }

      // Calculate metrics
      const metrics = this.calculateVulnerabilityMetrics(vulnerabilities);

      // Update scan with results
      await supabase
        .from('security_scans')
        .update({
          status: 'completed',
          completed_at: new Date().toISOString(),
          total_vulnerabilities: metrics.totalVulnerabilities,
          critical_vulnerabilities: metrics.criticalVulnerabilities,
          high_vulnerabilities: metrics.highVulnerabilities,
          medium_vulnerabilities: metrics.mediumVulnerabilities,
          low_vulnerabilities: metrics.lowVulnerabilities,
          summary: this.generateScanSummary(metrics),
          recommendations: this.generateRecommendations(vulnerabilities)
        })
        .eq('id', scanId);

      // Store vulnerabilities
      if (vulnerabilities.length > 0) {
        const vulnerabilityRecords = vulnerabilities.map(vuln => ({
          scan_id: scanId,
          severity: vuln.severity,
          category: vuln.category,
          title: vuln.title,
          description: vuln.description,
          cve: vuln.cve,
          cvss_score: vuln.cvssScore,
          affected_component: vuln.affectedComponent,
          file_path: vuln.filePath,
          line_number: vuln.lineNumber,
          remediation: vuln.remediation,
          references: vuln.references,
          status: 'open'
        }));

        await supabase
          .from('vulnerabilities')
          .insert(vulnerabilityRecords);
      }

    } catch (error) {
      console.error(`Scan ${scanId} failed:`, error);
      
      // Update scan status to failed
      await supabase
        .from('security_scans')
        .update({
          status: 'failed',
          completed_at: new Date().toISOString(),
          error_message: error instanceof Error ? error.message : 'Unknown error'
        })
        .eq('id', scanId);
    }
  }

  /**
   * Scan dependencies for vulnerabilities
   */
  private async scanDependencies(_target: string): Promise<VulnerabilityReport[]> {
    // In a real implementation, this would:
    // 1. Parse package.json/requirements.txt/etc.
    // 2. Check against vulnerability databases (NVD, Snyk, etc.)
    // 3. Return found vulnerabilities
    
    // For now, return mock data
    return [
      {
        id: `vuln_${Date.now()}_1`,
        scanId: '',
        severity: 'high',
        category: 'dependency',
        title: 'Vulnerable Package: lodash',
        description: 'lodash version 4.17.15 has a prototype pollution vulnerability',
        cve: 'CVE-2021-23337',
        cvssScore: 7.2,
        affectedComponent: 'lodash@4.17.15',
        remediation: 'Update lodash to version 4.17.21 or later',
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-23337'],
        discoveredAt: new Date().toISOString(),
        status: 'open'
      }
    ];
  }

  /**
   * Scan code for security issues
   */
  private async scanCode(_target: string): Promise<VulnerabilityReport[]> {
    // In a real implementation, this would:
    // 1. Use static analysis tools (ESLint security, SonarQube, etc.)
    // 2. Check for common vulnerabilities (OWASP Top 10)
    // 3. Return found issues
    
    // For now, return mock data
    return [
      {
        id: `vuln_${Date.now()}_2`,
        scanId: '',
        severity: 'medium',
        category: 'code',
        title: 'SQL Injection Vulnerability',
        description: 'Potential SQL injection in user query construction',
        affectedComponent: 'src/api/users.ts',
        filePath: 'src/api/users.ts',
        lineNumber: 45,
        remediation: 'Use parameterized queries or prepared statements',
        references: ['https://owasp.org/www-community/attacks/SQL_Injection'],
        discoveredAt: new Date().toISOString(),
        status: 'open'
      }
    ];
  }

  /**
   * Scan container images for vulnerabilities
   */
  private async scanContainer(_target: string): Promise<VulnerabilityReport[]> {
    // In a real implementation, this would:
    // 1. Use tools like Trivy, Clair, or Snyk
    // 2. Scan container layers for known vulnerabilities
    // 3. Return found issues
    
    return [];
  }

  /**
   * Scan infrastructure for security issues
   */
  private async scanInfrastructure(_target: string): Promise<VulnerabilityReport[]> {
    // In a real implementation, this would:
    // 1. Use tools like AWS Security Hub, Azure Security Center
    // 2. Check for misconfigurations, exposed services
    // 3. Return found issues
    
    return [];
  }

  /**
   * Scan for exposed secrets
   */
  private async scanSecrets(target: string): Promise<VulnerabilityReport[]> {
    // In a real implementation, this would:
    // 1. Use tools like TruffleHog, GitLeaks, or detect-secrets
    // 2. Scan code repositories for hardcoded secrets
    // 3. Return found secrets
    
    const secrets = await this.detectSecrets(target);
    
    return secrets.map(secret => ({
      id: `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      scanId: '',
      severity: 'critical',
        category: 'code',
      title: `Exposed Secret: ${secret.type}`,
      description: `Hardcoded ${secret.type} found in ${secret.filePath}`,
      affectedComponent: secret.value,
      filePath: secret.filePath,
      lineNumber: secret.lineNumber,
      remediation: 'Remove the secret from code and use environment variables or secret management',
      references: ['https://owasp.org/www-community/vulnerabilities/Use_of_Hard-coded_Credentials'],
      discoveredAt: new Date().toISOString(),
      status: 'open'
    }));
  }

  /**
   * Detect secrets in code
   */
  private async detectSecrets(_target: string): Promise<Array<{
    type: string;
    value: string;
    filePath: string;
    lineNumber: number;
  }>> {
    // In a real implementation, this would scan the codebase
    // For now, return mock data
    return [
      {
        type: 'API Key',
        value: 'sk-1234567890abcdef',
        filePath: 'src/config/api.ts',
        lineNumber: 12
      }
    ];
  }

  /**
   * Calculate vulnerability metrics
   */
  private calculateVulnerabilityMetrics(vulnerabilities: VulnerabilityReport[]): VulnerabilityMetrics {
    const total = vulnerabilities.length;
    const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
    const high = vulnerabilities.filter(v => v.severity === 'high').length;
    const medium = vulnerabilities.filter(v => v.severity === 'medium').length;
    const low = vulnerabilities.filter(v => v.severity === 'low').length;
    const open = vulnerabilities.filter(v => v.status === 'open').length;
    const resolved = vulnerabilities.filter(v => v.status === 'resolved').length;

    // Calculate security score (0-100)
    const securityScore = Math.max(0, 100 - (critical * 20) - (high * 10) - (medium * 5) - (low * 2));

    // Group by type
    const typeCounts = vulnerabilities.reduce((acc, vuln) => {
      acc[vuln.category] = (acc[vuln.category] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const topVulnerabilityTypes = Object.entries(typeCounts)
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    return {
      totalVulnerabilities: total,
      criticalVulnerabilities: critical,
      highVulnerabilities: high,
      mediumVulnerabilities: medium,
      lowVulnerabilities: low,
      openVulnerabilities: open,
      resolvedVulnerabilities: resolved,
      averageResolutionTime: 0, // Would calculate from historical data
      topVulnerabilityTypes,
      securityScore
    };
  }

  /**
   * Generate scan summary
   */
  private generateScanSummary(metrics: VulnerabilityMetrics): string {
    return `Found ${metrics.totalVulnerabilities} vulnerabilities: ${metrics.criticalVulnerabilities} critical, ${metrics.highVulnerabilities} high, ${metrics.mediumVulnerabilities} medium, ${metrics.lowVulnerabilities} low. Security score: ${metrics.securityScore}/100.`;
  }

  /**
   * Generate recommendations
   */
  private generateRecommendations(vulnerabilities: VulnerabilityReport[]): string[] {
    const recommendations: string[] = [];

    const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
    const secretCount = vulnerabilities.filter(v => v.category === 'dependency').length;

    if (criticalCount > 0) {
      recommendations.push('Immediately address all critical vulnerabilities');
    }

    if (highCount > 0) {
      recommendations.push('Prioritize resolution of high-severity vulnerabilities');
    }

    if (secretCount > 0) {
      recommendations.push('Implement secrets management solution');
      recommendations.push('Rotate all exposed secrets immediately');
    }

    if (vulnerabilities.some(v => v.category === 'dependency')) {
      recommendations.push('Implement automated dependency scanning in CI/CD');
      recommendations.push('Keep all dependencies up to date');
    }

    if (vulnerabilities.some(v => v.category === 'code')) {
      recommendations.push('Implement static code analysis in development workflow');
      recommendations.push('Conduct security code reviews');
    }

    return recommendations;
  }

  /**
   * Get vulnerability metrics
   */
  public async getVulnerabilityMetrics(): Promise<VulnerabilityMetrics> {
    try {
      const { data: vulnerabilities, error } = await supabase
        .from('vulnerabilities')
        .select('*');

      if (error) {
        throw error;
      }

      return this.calculateVulnerabilityMetrics(vulnerabilities || []);
    } catch (error) {
      console.error('Get vulnerability metrics failed:', error);
      throw error;
    }
  }

  /**
   * Get recent scans
   */
  public async getRecentScans(limit: number = 10): Promise<SecurityScanResult[]> {
    try {
      const { data: scans, error } = await supabase
        .from('security_scans')
        .select('*')
        .order('started_at', { ascending: false })
        .limit(limit);

      if (error) {
        throw error;
      }

      return scans || [];
    } catch (error) {
      console.error('Get recent scans failed:', error);
      throw error;
    }
  }

  /**
   * Get vulnerabilities by scan
   */
  public async getVulnerabilitiesByScan(scanId: string): Promise<VulnerabilityReport[]> {
    try {
      const { data: vulnerabilities, error } = await supabase
        .from('vulnerabilities')
        .select('*')
        .eq('scan_id', scanId);

      if (error) {
        throw error;
      }

      return vulnerabilities || [];
    } catch (error) {
      console.error('Get vulnerabilities by scan failed:', error);
      throw error;
    }
  }

  /**
   * Update vulnerability status
   */
  public async updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: VulnerabilityReport['status'],
    assignedTo?: string,
    dueDate?: string
  ): Promise<void> {
    try {
      const updateData: any = { status };
      
      if (assignedTo) updateData.assigned_to = assignedTo;
      if (dueDate) updateData.due_date = dueDate;
      if (status === 'resolved') updateData.resolved_at = new Date().toISOString();

      const { error } = await supabase
        .from('vulnerabilities')
        .update(updateData)
        .eq('id', vulnerabilityId);

      if (error) {
        throw error;
      }
    } catch (error) {
      console.error('Update vulnerability status failed:', error);
      throw error;
    }
  }

  /**
   * Create secret
   */
  public async createSecret(secret: Omit<SecretInfo, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    try {
      // Encrypt the secret value
      const encryptedResult = await encryptData(secret.name, generateKey());
      
      const { data, error } = await supabase
        .from('secrets')
        .insert({
          name: secret.name,
          type: secret.type,
          description: secret.description,
          environment: secret.environment,
          encrypted_value: encryptedResult.encrypted,
          encryption_key: encryptedResult.iv,
          is_encrypted: true,
          last_rotated: secret.lastRotated,
          expires_at: secret.expiresAt,
          is_active: secret.isActive,
          tags: secret.tags
        })
        .select('id')
        .single();

      if (error) {
        throw error;
      }

      return data.id;
    } catch (error) {
      console.error('Create secret failed:', error);
      throw error;
    }
  }

  /**
   * Get secrets
   */
  public async getSecrets(): Promise<SecretInfo[]> {
    try {
      const { data: secrets, error } = await supabase
        .from('secrets')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) {
        throw error;
      }

      return (secrets || []).map(secret => ({
        id: secret.id,
        name: secret.name,
        type: secret.type,
        description: secret.description,
        environment: secret.environment,
        isEncrypted: secret.is_encrypted,
        lastRotated: secret.last_rotated,
        expiresAt: secret.expires_at,
        isActive: secret.is_active,
        tags: secret.tags || [],
        createdAt: secret.created_at,
        updatedAt: secret.updated_at
      }));
    } catch (error) {
      console.error('Get secrets failed:', error);
      throw error;
    }
  }

  /**
   * Rotate secret
   */
  public async rotateSecret(secretId: string, newValue: string): Promise<void> {
    try {
      // Encrypt the new value
      const encryptedResult = await encryptData(newValue, generateKey());
      
      const { error } = await supabase
        .from('secrets')
        .update({
          encrypted_value: encryptedResult.encrypted,
          encryption_key: encryptedResult.iv,
          last_rotated: new Date().toISOString()
        })
        .eq('id', secretId);

      if (error) {
        throw error;
      }
    } catch (error) {
      console.error('Rotate secret failed:', error);
      throw error;
    }
  }

  /**
   * Delete secret
   */
  public async deleteSecret(secretId: string): Promise<void> {
    try {
      const { error } = await supabase
        .from('secrets')
        .delete()
        .eq('id', secretId);

      if (error) {
        throw error;
      }
    } catch (error) {
      console.error('Delete secret failed:', error);
      throw error;
    }
  }

  /**
   * Start scan processor
   */
  private startScanProcessor(): void {
    // Process scan queue every 30 seconds
    setInterval(() => {
      this.processScanQueue();
    }, 30000);
  }
}

// Export singleton instance
export const vulnerabilityService = VulnerabilityService.getInstance();